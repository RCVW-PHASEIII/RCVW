<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="keywords" content="gps, gpsd, internals">
<meta name="author" content="Mick Durkin">
<title>A Tour of the GPSD Internals</title>
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>

/* gpsd CSS customization. */
#header > h1:first-child,
body {
  color: #000;
}

.sidebarblock,
#toc.toc2 {
  background: #f8f8f8;
  border: 1px dashed #999;
}

.sidebarblock {
  display: inline-block;
  float: left;
  margin-right: 20px;
  margin-bottom: 20px;
}

#toctitle {
  display: none;
}

#content #toc.toc {
  background: inherit;
  border: none;
  padding: 0em;
}

#header,
#content,
#footnotes,
#footer {
  max-width: initial;
}

@media screen and (min-width: 768px) {
  body {
    --left-col: 15em;
  }

  #content #Menu {
    border: 1px dashed #999;
    bottom: 2px;
    left: 2px;
    margin: 0 20px 20px 0;
    position: absolute;
    top: 2px;
    width: var(--left-col);
  }

  #content #preamble,
  #content .sect1 {
    margin-left: calc(var(--left-col) + 22px);
  }
}
</style>
</head>
<body class="article">
<div id="header">
<h1>A Tour of the GPSD Internals</h1>
<div class="details">
<span id="author" class="author">Mick Durkin</span><br>
<span id="email" class="email"><a href="mailto:mick.durkin@saunalahti.fi">mick.durkin@saunalahti.fi</a></span><br>
<span id="revnumber">version 2.3,</span>
<span id="revdate">26 January 2021</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="Menu" class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><span class="image"><img src="gpsd-logo-small.png" alt="Small gpsd Logo" width="105" height="126"></span><br>
<a href="index.html">Home</a><br>
<a href="faq.html">FAQ</a><br>
<a href="xgps-sample.html">Screenshots</a><br>
<a href="hardware.html">Hardware</a><br>
<a href="for-vendors.html">For GPS Vendors</a><br>
<a href="wishlist.html">Wish List</a><br>
<a href="hall-of-shame.html">Hall of Shame</a><br>
<a href="troubleshooting.html">Troubleshooting Guide</a><br>
<a href="hacking.html">Hacker&#8217;s Guide</a><br>
<a href="references.html">References</a><br>
<a href="protocol-transition.html">Application Compatibility</a><br>
<a href="history.html">History</a><br>
<a href="future.html">Future</a><br></p>
</div>
<hr>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#_bits_h"><code>bits.h</code></a></li>
<li><a href="#_dbusexport_c"><code>dbusexport.c</code></a></li>
<li><a href="#_driver_nmea_c"><code>driver_nmea.c</code></a></li>
<li><a href="#_driver_proto_c"><code>driver_proto.c</code></a></li>
<li><a href="#_driver_rtcm2_c"><code>driver_rtcm2.c</code></a></li>
<li><a href="#_drivers_c"><code>drivers.c</code></a></li>
<li><a href="#_geoid_c"><code>geoid.c</code></a></li>
<li><a href="#_gps_h"><code>gps.h</code></a></li>
<li><a href="#_gpsd_c"><code>gpsd.c</code></a></li>
<li><a href="#_gpsd_h"><code>gpsd.h</code></a></li>
<li><a href="#_gpsd_log_c"><code>gpsd_log.c</code></a></li>
<li><a href="#_gpsutils_c"><code>gpsutils.c</code></a></li>
<li><a href="#_isgps_c"><code>isgps.c</code></a></li>
<li><a href="#_libgps_core_c"><code>libgps_core.c</code></a></li>
<li><a href="#_libgps_c"><code>libgps.c</code></a></li>
<li><a href="#_libgpsd_core_c"><code>libgpsd_core.c</code></a></li>
<li><a href="#_libgpsmm_cpp"><code>libgpsmm.cpp</code></a></li>
<li><a href="#_libgpsmm_h"><code>libgpsmm.h</code></a></li>
<li><a href="#_net_dgnss_dispatch_c"><code>net_dgnss_dispatch.c</code></a></li>
<li><a href="#_net_dgpsip_c"><code>net_dgpsip.c</code></a></li>
<li><a href="#_net_ntrip_c"><code>net_ntrip.c</code></a></li>
<li><a href="#_netlib_c"><code>netlib.c</code></a></li>
<li><a href="#_ntpshmwrite_c"><code>ntpshmwrite.c</code></a></li>
<li><a href="#_packet_c"><code>packet.c</code></a></li>
<li><a href="#_packet_names_h"><code>packet_names.h</code></a></li>
<li><a href="#_packet_states_h"><code>packet_states.h</code></a></li>
<li><a href="#_pseudonmea_c"><code>pseudonmea.c</code></a></li>
<li><a href="#_serial_c"><code>serial.c</code></a></li>
<li><a href="#_subframe_c"><code>subframe.c</code></a></li>
<li><a href="#_signoff">Signoff</a></li>
<li><a href="#_revision_history">Revision History</a></li>
<li><a href="#_copying">COPYING</a></li>
</ul>
</div>
<hr>
<div class="paragraph">
<p><a href="http://www.catb.org/hacker-emblem/"><span class="image"><img src="glider.png" alt="hacker emblem" width="55" height="55"></span></a><br>
<br>
<a href="https://validator.w3.org/check/referer"><span class="image"><img src="html5.png" alt="Valid HTML 5" width="88" height="31"></span></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abstract"><a class="link" href="#_abstract">Abstract</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>These notes are meant as an aid to reading and understanding some
of the main code files forming the <strong>gpsd</strong> daemon and its support
libraries. They are not a line-by-line explanation but only pick out the
important (or unusual) aspects of the code.</p>
</div>
<div class="paragraph">
<p>They do not address the many programs that are used for test purposes,
the individual device driver files or any of the supplied applications
that use <strong>gpsd</strong>.</p>
</div>
<div class="paragraph">
<p>This guide was written in 2007 before the move to a JSON-based protocol
and before AIS support was added.  The machinery relating to JSON and
AIS is not yet documented here.  While the information on the rest of
the code has been updated as of 2011.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bits_h"><a class="link" href="#_bits_h"><code>bits.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">This file only contains macros that convert data variables from the
native format of the device output (MSB-first or LSB-first) into a
standard form for <code>gpsd</code> use. This makes data parsing consistent
regardless of the underlying format. If the device driver file makes no
deliberate selection, the default is to assume the device emits data in
big-endian (network byte) order.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dbusexport_c"><a class="link" href="#_dbusexport_c"><code>dbusexport.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Handles initialization of and communication with the DBUS.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int initialize_dbus_connection(void)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initializes the DBUS
connection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void send_dbus_fix(struct gps_device_t* channel)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sends the current
fix data for this channel via dbus</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_nmea_c"><a class="link" href="#_driver_nmea_c"><code>driver_nmea.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Parser for NMEA strings, generic and proprietary.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void do_lat_lon(char *field[], struct gps_fix_t *out)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reads
a four element array containing the value and hemisphere of the latitude
and longitude of a location as text. It converts them into signed (-ve
for S and W) values. The gps_data_t structure is updated with the new
value(s).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void merge_ddmmyy(char *ddmmyy, struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the century has not yet been stored in the nmea driver private data,
take the supplied ddmmyy date and generate and store a ddmmyyyy date,
using the century value compiled in from <code>gpsd.h</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void merge_hhmmss(char *hhmmss, struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stash the present hour value before updating it from the incoming data.
If the new hour is less than the stashed value, we have passed midnight,
so update the day value. Finally update the minutes, seconds and
fractions of a second from the incoming data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPRMC(int count, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Handle a $GPRMC sentence stored in an array of strings, one member per
field.</p>
</div>
<div class="paragraph">
<p>Check if the message is stamped valid or not.</p>
</div>
<div class="paragraph">
<p>If it is invalid, set the status and fix mode to NO_FIX and save the
corresponding flags locally; also save the online flag to indicate we
have handled a known sentence.</p>
</div>
<div class="paragraph">
<p>If the fix is autonomous and valid, start to decode the fields.</p>
</div>
<div class="paragraph">
<p>First, test if there are enough fields available; then handle the date
and time via <code>merge_ddmmyy()</code> and <code>merge_hhmmss()</code>, storing the
TIME_SET flag and storing the fix time as a UNIX-epoch relative value.</p>
</div>
<div class="paragraph">
<p>If the sentence time and this fix time are different, we have started a
new cycle of observation, so update the sentence time and the store the
CYCLE_START_SET flag.</p>
</div>
<div class="paragraph">
<p>Whatever the number of fields, store the fix coordinates via
<code>do_lat_lon()</code>, store the speed and the track and save the
corresponding flags.</p>
</div>
<div class="paragraph">
<p>Return the local aggregated flags to allow the main copy in the session
data to be updated.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPGLL(int count, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Preload the local flag with the ERROR_SET flag.</p>
</div>
<div class="paragraph">
<p>Check that the sentence is usable, exiting with the preset error flag if
it is not.</p>
</div>
<div class="paragraph">
<p>If it is usable, clear the local flags and start processing the fields,
updating any local flag fields on the way.</p>
</div>
<div class="paragraph">
<p>If the year is already known, update the time and check for the start of
cycle (see <code>processGPRMC()</code> above).</p>
</div>
<div class="paragraph">
<p>Handle the fix location and, if the number of received fixes is more
than 8 and set fix status.</p>
</div>
<div class="paragraph">
<p>If the present mode is less than 2D_FIX, update it to 2D_FIX.</p>
</div>
<div class="paragraph">
<p>Write the stashed value of newstatus into the session status and return
all the locally aggregated flags.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPGGA(int c UNUSED, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Stash the last fix time. Set the status to the value in the message and
update the local flag variable.</p>
</div>
<div class="paragraph">
<p>If the status is STATUS_UNK, exit immediately, returning the locally
aggregated flags. If there is a fix, process it.</p>
</div>
<div class="paragraph">
<p>Handle the time as in <code>processGPGLL()</code> above. Handle the latitiude and
longitude with a call to <code>do_lat_lon()</code> above and set the local flag.</p>
</div>
<div class="paragraph">
<p>Update the <code>satellites_used</code> field and stash the altitude.</p>
</div>
<div class="paragraph">
<p>If the altitude is empty, force the fix mode and status to 2D if it was
3D previously.</p>
</div>
<div class="paragraph">
<p>If it is not empty, stash the old value of altitude and replace it with
the new value stashed earlier and set the local flag variable. If the
mode is presently less than 3D, update it to 3D and set the local flag.</p>
</div>
<div class="paragraph">
<p>If the stashed old altitude is NaN or the stashed fix time and current
fix time are equal, set the climb rate to 0 otherwise calculate it by
dividing the altitude difference by the time difference and set the
local flag.</p>
</div>
<div class="paragraph">
<p>If the geoid separation is available, store it, otherwise store the
value from <code>wgs84_separation()</code> that depends on current location.</p>
</div>
<div class="paragraph">
<p>Finally, return all the locally aggregated flags.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPGSA(int count, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Start with a simple validity check on the number of fields (for i.Trek
M3) and bail out with a simple indication of on-line status if it fails.</p>
</div>
<div class="paragraph">
<p>Set the fix mode from the sentence and either clear the local flag
variable (if an Antaris chipset says we are in dead-reckoning mode) or
set the MODE_SET flag.</p>
</div>
<div class="paragraph">
<p>Update all the DOP fields from the sentence, clear the count of used
satellites, then scan all the satellite data.</p>
</div>
<div class="paragraph">
<p>If any satellite is good (prn != 0), store the prn and increment the
count of used satellites.</p>
</div>
<div class="paragraph">
<p>Finally, set the local flags to indicate that DOPs are available and
return all the locally aggregated flags.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPGSV(int count, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check if the sentence has too few fields or the wrong number of fields.
In this case, clear the data for all satellites and return with an error
indication.</p>
</div>
<div class="paragraph">
<p>Start to parse the sentence. First, note how many sentences are to be
expected to complete the data transfer.</p>
</div>
<div class="paragraph">
<p>If the sentence number is invalid, clear the data for all satellites and
return with an error indication.</p>
</div>
<div class="paragraph">
<p>If this is the first sentence of the sequence, clear the data for all
satellites.</p>
</div>
<div class="paragraph">
<p>Loop through the sentence fields, updating the session&#8217;s satellite data.</p>
</div>
<div class="paragraph">
<p>If any satellite number is higher than the number of channels, clear all
satellite data and break out of the loop.</p>
</div>
<div class="paragraph">
<p>Assuming this is not a buggy chipset (e.g. Motorola Oncore GT+), update
the satellite count and loop again.</p>
</div>
<div class="paragraph">
<p>If this was the last sentence of the block and the number of satellites
seen is not the same as the number reported, generate an error log.</p>
</div>
<div class="paragraph">
<p>If this is not the last sentence of the block, exit early and return an
error flag as a guard.</p>
</div>
<div class="paragraph">
<p>Finally, on the last sentence, carry out a sanity check and either
return an error flag or a SATELLITE_SET flag.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processPGRME(int c UNUSED, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check that the error estimate data is good. If not, set all error
estimate fields to 100m and return an error flag.</p>
</div>
<div class="paragraph">
<p>If they are good, calculate the error value and store it. Return the
appropriate flag values.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processGPZDA(int c UNUSED, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Set the local flag variable to indicate that the time is available.</p>
</div>
<div class="paragraph">
<p>Store the actual time by a call to <code>merge_hhmmss()</code> and fill in the
other fields from the sentence data.</p>
</div>
<div class="paragraph">
<p>If the sentence is not timestamped the same as the fixtime, set the
CYCLE_START_SET flag.</p>
</div>
<div class="paragraph">
<p>Update the fixtime to the sentence timestamp.</p>
</div>
<div class="paragraph">
<p>Finally, return all the locally aggregated flags.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t processTNTHTM(int c UNUSED, char *field[], struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Set the local variable to indicate the unit is on-line.</p>
</div>
<div class="paragraph">
<p>Fill all appropriate fields from the sentence and set the associated
flags in the local flag variable.</p>
</div>
<div class="paragraph">
<p>Set the fix status and return all the locally aggregated flags.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static short nmea_checksum(char *sentence, unsigned char *correct_sum)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calculate and return the checksum of an NMEA sentence.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gps_mask_t nmea_parse(char *sentence, struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Test that the length of the NMEA sentence is acceptable, simply
returning an on-line indication if it is too long to handle.</p>
</div>
<div class="paragraph">
<p>If it is within limits, make a local copy and split it on the commas
into an array, one field per element.</p>
</div>
<div class="paragraph">
<p>Use the first element to match the command to the table of decodable
commands.</p>
</div>
<div class="paragraph">
<p>Check if it is supported and the number of fields is reasonable, invoke
the correct decoder and return the value from that call.</p>
</div>
<div class="paragraph">
<p>If it fails the check, simply return an on-line status.</p>
</div>
<div class="paragraph">
<p>This function is also responsible for performing adaptive end-of-cycle
detection.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void nmea_add_checksum(char *sentence)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calculate the checksum then
append '<strong>' + the checksum + CR/LF to the end of an NMEA sentence,
skipping any existing '</strong>'.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int nmea_write(struct gps_device_t *session, const char *fmt, ... )</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ship a string to an NMEA device, adding a checksum and CR/LF if needed.
A checksum is added only if the sentence begins with '$'. Bytes written
are returned.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int nmea_send(struct gps_device_t *session, , const char *fmt, ... )</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A wrapper around <code>nmea_write()</code> to give it sprintf-like varargs
behavior.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_proto_c"><a class="link" href="#_driver_proto_c"><code>driver_proto.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a dummy file to use as a skeleton for writing a new driver. The
driver is heavily commented, so refer to the source code.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_driver_rtcm2_c"><a class="link" href="#_driver_rtcm2_c"><code>driver_rtcm2.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This is a decoder for the RTCM-104 serial protocol.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rtcm2_unpack(struct rtcm2_t *tp, char *buf)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Splits RTCM2 raw
data into fields.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool rtcm2_repack(struct rtcm2_t *tp, isgps30bits_t *buf)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Packs
RTCM2 fields into a raw data stream.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static bool preamble_match(isgps30bits_t *w)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tells if the preamble
field in a message is valid or not.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static bool length_check(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tells if the
message length is valid or not.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum isgpsstat_t rtcm2_decode(struct gps_packet_t *lexer, unsigned int c)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A simple call to <code>isgps_decode()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rtcm2_dump(struct rtcm2_t *rtcm2, char buf[], size_t buflen)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dump the contents of a parsed RTCM104v2 message.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rtcm2_output_magnavox(isgps30bits_t *ip, FILE *fp)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ship an
RTCM2 message in the format emitted by Magnavox DGPS receivers.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_drivers_c"><a class="link" href="#_drivers_c"><code>drivers.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This is the main driver for NMEA, both plain vanilla and
any manufacturer specific variety of NMEA output. This is NOT where
manufacturer specific binary matters are handled.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssize_t generic_get(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a
wrapper to call the real packet getter function, <code>packet_get()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssize_t pass_rtcm(struct gps_device_t *session, char *buf, size_t rtcmbytes)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This writes the rtcm data to the device.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gps_mask_t nmea_parse_input(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the packet is a comment packet, ignore it and return 0.</p>
</div>
<div class="paragraph">
<p>If it is one of several binary packets, issue a warning to that effect.</p>
</div>
<div class="paragraph">
<p>If the relevant driver exists, switch to that driver and get it to parse
the packet. The return value is that of the binary parser.</p>
</div>
<div class="paragraph">
<p>If the driver does not exist, ignore the packet and return 0.</p>
</div>
<div class="paragraph">
<p>If after all this, it is likely to be an NMEA packet, so try to parse it
with the NMEA parser. If that returns a 0 (unsuccessful), then check if
it is a trigger packet for one of the triggerable drivers.</p>
</div>
<div class="paragraph">
<p>If this succeeds, return 1, otherwise issue an unrecognised packet
error.</p>
</div>
<div class="paragraph">
<p>Finally checks are made against openBSD&#8217;s NMEA Line Discipline to make
use of timestamping and if ntpd synchronising is active, the time is
passed to the ntp daemon.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void nmea_probe_subtype(struct gps_device_t *session, unsigned int seq)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This tries to probe for the NMEA mode of several popular chipsets. Most
are detected by a trigger string.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Several functions are omitted which are device specific. These are
not covered here since they ARE device specific.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static gps_mask_t rtcm104_analyze(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This function calls <code>rtcm_unpack()</code> to unpack rtcm packets into the
session buffer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The last important thing in this code is an array of addresses, one
for each compiled-in driver. This address gets us to the
&#8220;capabilities&#8221; table in the bottom of each driver where we find what
functions a driver supports and the entry address for each function.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_geoid_c"><a class="link" href="#_geoid_c"><code>geoid.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Provides conversion between the ECEF and WGS84 coordinate
reference systems.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static double bilinear(double x1, double y1, double x2, double y2, double x, double y, double z11, double z12, double z21, double z22)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a piece of mathematical manipulation only used internally in
this code, so wrestle with it if you will! It&#8217;s used to perform bilinear
interpolation on the grid points in the WGS4 geoidal-separation array.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double wgs84_separation(double lat, double lon)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is used by
drivers to get the separation of MSL from the WGS84 datum at a pair of
Latitude/Longitude coordinates. The data is in a pre-defined table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void ecef_to_wgs84fix(struct gps_data_t *gpsdata, double x,
double y, double z, double vx, double vy, double vz)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This does
exactly what it says! Coordinate system conversion from ecef to the
wgs84 equivalent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static double fix_minuz(double d)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This forces a value of -0.0 to
be the same as 0.0 so that certain trig functions act in a predictable
manner.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int main(int argc, char **argv)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a local test routine which
exercises the other code for debugging purposes. It is normally shut off
by an <code>#ifdef</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gps_h"><a class="link" href="#_gps_h"><code>gps.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Structures:</th>
<th class="tableblock halign-left valign-top">The interface of the libgps library, provides data
structures the library needs and that the daemon fills.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_fix_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the fix related data gathered from the
gps device. Each client session has 2, the current fix and the previous
fix.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct rtcm2_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This holds the data being processed by the rtcm
functions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_data_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This contains ALL the data available from the
daemon; the actual fix, status flags, headings etc. Basically any good
stuff that we might want goes here.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpsd_c"><a class="link" href="#_gpsd_c"><code>gpsd.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This is the main body of the daemon.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void onsig(int sig)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a simple catchall routine to
trap wanted signal. Simply store the signal number in a variable to
advise the main loop which signal to handle.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int daemonize(void)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Try to <code>fork()</code> a child process. The parent will get a return value of
either -1 (on a failure to <code>fork()</code>) or non-zero (the child&#8217;s PID).
The parent routine will use this information to either return -1 or exit
with an exit code of 0 (i.e. the parent terminates, leaving the child
running).</p>
</div>
<div class="paragraph">
<p>The child instance gets a return value of 0 (on an unsuccessful
<code>fork()</code> there is no child), so this value is used as the trigger to
do the following useful stuff.</p>
</div>
<div class="paragraph">
<p>First, the child tries to create a new session, returning -1 if unable
to do so. If successful, it will have inherited the exiting parent&#8217;s
session.</p>
</div>
<div class="paragraph">
<p>Next switch to the root directory and try to open &#8220;/dev/null&#8221;. If that
succeeds, force stdin, stdout and stderr to duplicate the fd of
&#8220;/dev/null&#8221;. If the fd being used for the operation is &gt;2, release it.</p>
</div>
<div class="paragraph">
<p>Finally, set the flag which indicates the process is in the background
and return a value of 0.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void usage(void)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simply print a big list of the invocation
parameters to the default gpsd port (2947, allocated by IANA).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int passivesock_af(char *service, char *tcp_or_udp, int qlen)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Initialise an Internet socket address structure and preload the family
and address fields to accept Internet Protocol and any address.</p>
</div>
<div class="paragraph">
<p>Test to see if the incoming service and protocol exist in
<code>/etc/services</code>. If they do, store the port number in the structure
(massaging byte order as needed); if they don&#8217;t, exit with a -1.</p>
</div>
<div class="paragraph">
<p>Test to see if the protocol is listed in <code>/etc/services</code>, exiting with
-1 if it is not.</p>
</div>
<div class="paragraph">
<p>Test if the protocol is udp or not, setting the type accordingly.</p>
</div>
<div class="paragraph">
<p>Try to open a socket with the accumulated settings, exiting with -1 if
it fails.</p>
</div>
<div class="paragraph">
<p>Try to set the socket options correctly, again exiting with -1 if it
fails.</p>
</div>
<div class="paragraph">
<p>Try to bind to the open socket; if it fails exit with -1 as earlier, but
give a special warning if the error indicates that gpsd may already be
active on the socket.</p>
</div>
<div class="paragraph">
<p>If we are using a stream type socket and we are unable to listen to the
port we exit with -1.</p>
</div>
<div class="paragraph">
<p>The last possibility is a successful set of operations which is
signalled by returning the socket fd number.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int passivesocks(char *service, char *tcp_or_udp, int qlen, int socks[])</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Open a passive socket for each supported address family; presently the
supported families are IPV4 and IPv6. This socket will be used to listen
for client command connections. Sockets are left in the final array
argument, and the number successfully opened is returned.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int filesock(char *filename)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Try and open a socket for Local (UNIX) communications in streaming mode.
If the open fails, return with a -1.</p>
</div>
<div class="paragraph">
<p>If it opens, copy the incoming filename into the socket control
structure, bind to the socket and try to listen on it.</p>
</div>
<div class="paragraph">
<p>Signal a failure by returning -1 and success by returning the socket fd
number.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void adjust_max_fd(int fd, bool on)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the incoming boolean flag is active, check if the fd number passed is
greater than the highest seen so far. If so, save it as the new highest
value.</p>
</div>
<div class="paragraph">
<p>If the boolean is passive we can take some further action, depending if
we are interested in limiting the maximum number of devices and client
fds (set by compile time options).</p>
</div>
<div class="paragraph">
<p>If we are not limiting ourselves, then we check for the case when we are
actually at the highest fd seen so far. In that case, scan through all
fds available to the system and store the highest active fd number in
our allocation set as the new highest value.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static struct subscriber_t* allocate_client(void)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Scan through all the client file descriptors, looking for one which does
not have a device allocated to it.</p>
</div>
<div class="paragraph">
<p>On a match, exit early, returning this fd.</p>
</div>
<div class="paragraph">
<p>If none are available, return a NULL.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void detach_client(struct subscriber_t *sub)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Close the given fd and remove it from our allocation set.</p>
</div>
<div class="paragraph">
<p>Make a call to <code>adjust_max_fd()</code> to housekeep the highest fd marker if
needed.</p>
</div>
<div class="paragraph">
<p>Set important fields in the client&#8217;s datablock to safe values for the
next re-use, then return.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static ssize_t throttled_write(struct subscriber_t *sub, char *buf, ssize_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check if we have a high enough debug level active to warrant printing
out the information we are about to send to the client.</p>
</div>
<div class="paragraph">
<p>Make the actual <code>write()</code> call and if that was successful, return the
counter value from that operation.</p>
</div>
<div class="paragraph">
<p>If we have suffered some kind of failure, try to analyse it.</p>
</div>
<div class="paragraph">
<p>On a short write, detach the client and return a 0.</p>
</div>
<div class="paragraph">
<p>Trap <code>EAGAIN</code> or <code>EINTR</code> and return a 0.</p>
</div>
<div class="paragraph">
<p>Trap <code>EBADF</code> or a <code>EWOULDBLOCK</code> where the client has not read data
for more than a reasonable amount of time and generate a suitable
report.</p>
</div>
<div class="paragraph">
<p>For all other errors, generate a general error. In these last several
cases, call <code>detach_cient()</code>.</p>
</div>
<div class="paragraph">
<p>Finally, return the status (-1 in this case).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void notify_watchers(struct gps_device_t *device, const char *sentence, ...)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>For every possible subscriber, check if the subscriber is in watcher
mode and is interested in the gps device indicated in the calling
parameter <code>gps_device_t</code>.</p>
</div>
<div class="paragraph">
<p>If so, send the data via a call to <code>throttled_write()</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static struct gps_device_t *find_device(const char *device_name)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>For every possible channel, check if the channel is allocated and if the
device on the channel is the one passed to us.</p>
</div>
<div class="paragraph">
<p>If it is so, exit early and return the channel number.</p>
</div>
<div class="paragraph">
<p>If there is no match, return a NULL.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void deactivate_device(struct gps_device_t *device)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deactivate device, but leave it in the device pool; do not free it.
This means it will be available to be watched on subsequent client
opens.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool open_device(struct gps_device_t *devp)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Try to activate the device via a call to <code>gpsd_activate()</code>.</p>
</div>
<div class="paragraph">
<p>If this fails return &#8220;false&#8221;.</p>
</div>
<div class="paragraph">
<p>If it succeeds, add the fd to our list of active fds, housekeep the
highest fd number and return &#8220;true&#8221;.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static bool add_device(const char *device_name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add a device to
the pool of those available. If in nowait mode, open it immediately;
otherwise initialize it and make it available for future watches, but
don&#8217;t open it yet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static bool awaken(struct subscriber_t *user, struct gps_device_t *device)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the device is not initialized, attempt to open the specified device
on behalf of the specified user. If you succeed and the device has an
active fd, you&#8217;re done. If it does not, make a call to
<code>gpsd_activate()</code>.</p>
</div>
<div class="paragraph">
<p>If this fails, return &#8220;false&#8221;, if not, add the fd to our list of
active fds and housekeep the highest fd.</p>
</div>
<div class="paragraph">
<p>Check if the user is in watcher mode but not tied to a specific device.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static char *snarfline(char *p, char **out)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copy the input line
into a new buffer stopping at the first non-printable or whitespace
character.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static bool privileged_user(struct gps_device_t *device)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scan all
subscribers and count all who are connected to the device. If only the
one user is connected, return &#8220;true&#8221;, otherwise return &#8220;false&#8221;.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void handle_request(struct subscriber_t* sub, char *buf, const char **after, char *reply, size_t replylen)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perform a single GPSD JSON command. Accept the command response into a
reply buffer, and update the after pointer to point just after the
parsed JSON object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+static int handle_gpsd_request(struct subscriber_t *sub, const char *buf)
+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parse multiple GPSD JSON commands out of a buffer and perform each.
Ship all responses back to the user via <code>throttled_write()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void handle_control(int sfd, char *buf)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This code is similar in function to <code>handle_gpsd_request()</code> in that it
parses user input. It expects the commands to be one per line and
despatches them according to the leading character, which is limited to
one of '-', '+' or '!'.</p>
</div>
<div class="paragraph">
<p>In the first case, the body of the command is assumed to be a device to
remove from the search list. If found, it is removed, any clients are
advised and &#8220;OK&#8221; is written to the calling socket fd. If the device is
not found &#8220;ERROR&#8221; is written to the calling socket fd.</p>
</div>
<div class="paragraph">
<p>In the second case, the body of the command is assumed to be a device to
be used by the daemon. If the device is already known, or does not
respond to <code>open_device()</code>, &#8220;ERROR&#8221; is written to the calling socket
fd, otherwise &#8220;OK&#8221; is written.</p>
</div>
<div class="paragraph">
<p>In the third case, the command is assumed to be a device-specific
control string in the form &#8220;!device_name=control_string&#8221;. If the
string is ill-formed or the device is not found &#8220;ERROR&#8221; is written to
the calling socket fd. If all is well, the control string is written to
the device and &#8220;OK&#8221; is written to the calling socket fd.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int main(int argc, char *argv[])</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the 1PPS function is compiled in, initialise the local mutex
structure for use by the program.</p>
</div>
<div class="paragraph">
<p>A <code>while()</code> loop reads in any command line arguments which are options
and handles the options. Most set an internal variable to control action
when running, either to a fixed value or to the associated option&#8217;s
parameter.</p>
</div>
<div class="paragraph">
<p>Carry out a series of calls to routines to set things up ready for the
main task (e.g. opening a control socket if one is needed). We also take
care of tasks such as daemonizing when appropriate. The last piece of
preparation is to set the permissions of the default devices correctly
if we are daemonizing and are presently running as root.</p>
</div>
<div class="paragraph">
<p>Switch to the compiled in user name (typically &#8220;nobody&#8221;) and the group
used by the tty devices.</p>
</div>
<div class="paragraph">
<p>Now we clear important data for all the records in the subscriber list.</p>
</div>
<div class="paragraph">
<p>Use <code>setjmp()</code> to prepare things for when the daemon terminates.</p>
</div>
<div class="paragraph">
<p>Clear the semaphore variable which will contain the signal number if one
arrives and set some important signals so they are trapped by the stub
handler in <code>onsig()</code>.</p>
</div>
<div class="paragraph">
<p>Add the command and RTCM sockets (if active) to the list of active fds,
housekeeping the highest fd number and pre-clear the list of control
fds.</p>
</div>
<div class="paragraph">
<p>Process the remaining parameter on the command line which should be the
device name and try to open the specified device.</p>
</div>
<div class="paragraph">
<p>Enter the main execution loop, a <code>while()</code> loop which terminates if a
signal sets the semaphore variable. What follows will repeat over and
over until an external termination happens.</p>
</div>
<div class="paragraph">
<p>First we make a working copy of the active fds and then we make a
time-limited (1 second time limit) call to <code>select()</code> using the
working copy of the fds. This means that when the <code>select()</code> returns,
we will either have returned on timeout or because some fd became ready
to read.</p>
</div>
<div class="paragraph">
<p>First we check if any new clients have come active and (if we have
resources) allocate a subscriber slot to it, doing housekeeping such as
adding it to the main list of active fds and removing it from the local
copy of the list. If RTCM support is compiled in, the last operation is
repeated for any new RTCM client. The operation is then repeated for any
new control socket clients.</p>
</div>
<div class="paragraph">
<p>If we are expecting DGPS reports, make a call to <code>netgnss_poll()</code> and
if there are no ready reports, clear the fd from the main and local
active fd lists.</p>
</div>
<div class="paragraph">
<p>Check if any of the active control sockets has sent one or more
commands.</p>
</div>
<div class="paragraph">
<p>For every one which has sent commands, make calls to
<code>handle_control()</code> to process them and remove the associated fd from
the main and control lists of active fds.</p>
</div>
<div class="paragraph">
<p>Poll every active gps device and send RTCM data to it (if needed),
followed by reading its output (if any). If the device returns an error,
disable the device. If it has gone off-line, disable the device.</p>
</div>
<div class="paragraph">
<p>If we get here, we have something to handle, so we take care of a device
which we know about, but do not have a subtype for.</p>
</div>
<div class="paragraph">
<p>We send the available data to all subscribers who are connected to this
device. If the data is RTCM information, pass it to all GPS devices that
can accept the data.</p>
</div>
<div class="paragraph">
<p>Handle any subscribers who are in watcher mode building up an
appropriate set of requests, depending on the available data and passing
the requests to <code>handle_gpsd_request()</code>.</p>
</div>
<div class="paragraph">
<p>If we care about DBUS, send the fix to the DBUS.</p>
</div>
<div class="paragraph">
<p><em>Note that this small section of code is presently disabled pending
development of the DGNSS function.</em> If DGNSS is available and we have a
fix, we poll a DGNSS report via <code>dgnss_autoconnect()</code>.</p>
</div>
<div class="paragraph">
<p>Loop round all clients and process active ones. We check for input from
them and if the read fails, the client is released with
<code>detach_client()</code>. If it succeeds, any data is handled via
<code>handle_rtc_request()</code> or <code>handle_gpsd_request()</code>.</p>
</div>
<div class="paragraph">
<p>If the transaction fails, the client is released with
<code>detach_client()</code>.</p>
</div>
<div class="paragraph">
<p>If the client has timed out with no device assigned, it is released with
<code>detach_client()</code>.</p>
</div>
<div class="paragraph">
<p>If the client has a device, but has timed out on no response (when not
in raw or watcher modes) it is released with <code>detach_client()</code>.</p>
</div>
<div class="paragraph">
<p>If we are not running in &#8220;nowait&#8221; mode, we are supposed to go idle
after a timeout when there are no clients.</p>
</div>
<div class="paragraph">
<p>If a device (with a known type) has no active clients, then we can
actually make it idle via <code>gpsd_deactivate()</code>.</p>
</div>
<div class="paragraph">
<p>If we reach here, we are out of the endless while loop. We check if the
signal was <code>SIGHUP</code> and restart the program if it was. If it is any
other signal, we deallocate all channels and wrap up any devices.
Finally we check for the existence of a control socket or a pid file and
delete them.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpsd_h"><a class="link" href="#_gpsd_h"><code>gpsd.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Structures:</th>
<th class="tableblock halign-left valign-top">Provides fundamental types and structures for the GPS
daemon. Only key structures are analysed here. Simple definitions and
prototype definitions are ignored.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">This file is created at <code>configure</code> time by combining
<code>gpsd.h-head</code>, certain configuration options from the auto-generated
file <code>gpsd_configure.h</code> and <code>gpsd.h-tail</code>. This file (<code>gpsd.h</code>)
should not be edited directly, neither should <code>gpsd.h-head</code>. You
should only edit <code>gpsd.h-tail</code> as needed.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_packet_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides the data structure used by
<code>packet_getter()</code>. 1 per gpsd session.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_context_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides context data like number of good
fixes seen. 1 per gpsd session.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_type_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the method table that every driver
uses to communicate with the daemon. It is a table of entry points or
externally visible data. 1 per driver type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_device_t {}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the data belonging to a session
(global state) and also private storage for the session&#8217;s associated
device driver (if needed). 1 per gpsd session.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpsd_log_c"><a class="link" href="#_gpsd_log_c"><code>gpsd_log.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Direct access to GPSes on serial or USB devices.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_log(int errlevel, const struct errout_t, const char *fmt, ... )</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This code is used for error reporting, but is dependant on
SQUELCH_DISABLE so that embedded systems (for example) are not burdened
with unnecessary noise. The first thing to check is if the error level
offered is high enough to be of interest (controlled by the debug level
we are running at).</p>
</div>
<div class="paragraph">
<p>If we are interested, the first step is to protect the code with a mutex
if we are using the 1PPS input.</p>
</div>
<div class="paragraph">
<p>Now we build a message buffer which has a fixed header ("`gpsd: `") and
the incoming data. The output buffer is prepared (load the start with a
NULL) and then the input buffer is scanned, byte-by-byte, up to its
terminating NULL. The scanned data is transferred on the fly to the
output buffer subject to the following tests:</p>
</div>
<div class="paragraph">
<p>If the character is printable, it passes through unchanged.</p>
</div>
<div class="paragraph">
<p>If it is a space and either of the next two bytes is NULL it will also
pass through unchanged.</p>
</div>
<div class="paragraph">
<p>In any other case, it is copied across as a hexadecimal string like
&#8220;x09&#8221;.</p>
</div>
<div class="paragraph">
<p>The completed output buffer is then either sent to the system logger if
we are in background mode (daemon) or to the stderr file if we are in
foreground mode.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gpsd_switch_driver(struct gps_device_t *session, char* typename)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Test if the function is called with the same name as the active driver.</p>
</div>
<div class="paragraph">
<p>If it is, test if the driver has a configurator function and is able to
be reconfigured. A good result here will call the driver event hook with
type 'driver_switch', and return a 0.</p>
</div>
<div class="paragraph">
<p>For an entry with a different driver name, scan all available drivers to
see if the wanted one is there. An unmatched name exits, returning 0.</p>
</div>
<div class="paragraph">
<p>If we got a match, get the baudrate for the device with
<code>gpsd_assert_sync()</code>, probe for the subtype if we have one.</p>
</div>
<div class="paragraph">
<p>If the device has a configurator and is reconfigurable, trigger the
configurator.</p>
</div>
<div class="paragraph">
<p>Return a 1 to indicate a device switch.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_init(struct gps_device_t *session, struct gps_context_t *context, const char *device)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Copy the device name to the session data structure, initialise
important data fields and call <code>gpsd_tty_init()</code>,
<code>gpsd_zero_satellites()</code> and <code>packet_reset()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_deactivate(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All actions below, except the last one are conditional on the <code>ntpd</code>
interface being compiled in.</p>
</div>
<div class="paragraph">
<p>Release the <code>ntpd</code> resources, including the 1PPS resources if they are
active.</p>
</div>
<div class="paragraph">
<p>If the device has a revert function, trigger it.</p>
</div>
<div class="paragraph">
<p>If it has an NMEA mode switcher, invoke it.</p>
</div>
<div class="paragraph">
<p>If it has a wrapup routine, invoke it.</p>
</div>
<div class="paragraph">
<p>Finally, close the device.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void *gpsd_ppsmonitor(void *arg)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An <code>ioctl()</code> call is made which returns either 0 if the status of the
port changed, or an error.</p>
</div>
<div class="paragraph">
<p>If we got a change, we read the modem control bits and extract the 1PPS
information.</p>
</div>
<div class="paragraph">
<p>We check the returned value and see if it has changed recently. A
counter of 10 unchanged events will disable further testing.</p>
</div>
<div class="paragraph">
<p>If we are still hanging in there, we now see if we already have had more
than 4 good fixes, otherwise we can&#8217;t trust the 1PPS.</p>
</div>
<div class="paragraph">
<p>We then finally test the pulse duration. If it is either a genuine 1PPS
or a 2Hz square wave, we call <code>ntpshm_pps()</code>.</p>
</div>
<div class="paragraph">
<p>Short or long PPS pulses are dropped with an error report.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gpsd_activate(struct gps_device_t *session, bool reconfigurable)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the devicename matches an NTRIP or DGNSS URI, hand off to special
code for opening a socket to that source over the network.</p>
</div>
<div class="paragraph">
<p>Try and open the device, returning -1 if we fail.</p>
</div>
<div class="paragraph">
<p>Probe all possible drivers to see if one recognises the device.</p>
</div>
<div class="paragraph">
<p>Set some fundamental data to a clean value.</p>
</div>
<div class="paragraph">
<p>Handle the initialisation of NTP and 1PPS functions if needed.</p>
</div>
<div class="paragraph">
<p>If we did succeed in probing some device type, try and get the subtype.</p>
</div>
<div class="paragraph">
<p>If we need to do so, we now configure the device.</p>
</div>
<div class="paragraph">
<p>Finally, signal success by returning the file descriptor given by the
device open call.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_error_model(struct gps_device_t *session, struct gps_fix_t *fix, struct gps_fix_t *oldfix)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check we have a 2D fix (or better) and if the gps didn&#8217;t provide an eph
value, use the HDOP to calculate one or fail to NAN.</p>
</div>
<div class="paragraph">
<p>Do the same with epv/VDOP if we have a 3D or better fix.</p>
</div>
<div class="paragraph">
<p>Do the same with epe/PDOP.</p>
</div>
<div class="paragraph">
<p>Consider speed error; check if we have two fixes with differing
timestamps and use their times and eph values to calculate the speed.</p>
</div>
<div class="paragraph">
<p>If we have two valid 3D fixes, we can calculate the climb/sink rate.</p>
</div>
<div class="paragraph">
<p>Finally, just before exiting, save this fix as the old fix for the next
comparison round.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gps_mask_t gpsd_poll(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Make a call to <code>gps_clear_fix()</code> to prepare the newdata structure to
receive data from an incoming packet.</p>
</div>
<div class="paragraph">
<p>Check if we know the device type. If we do, stash the count of of
characters we are able to get from it.</p>
</div>
<div class="paragraph">
<p>If the read has given a full packet, we can call the subtype probing
method, if the device supports it.</p>
</div>
<div class="paragraph">
<p>If we don&#8217;t know the device type, try and figure out what it is, exiting
if we can&#8217;t.</p>
</div>
<div class="paragraph">
<p>Make some checks if the device is offline or the packet is incomplete,
using the stashed count of characters and the full packet indicator.</p>
</div>
<div class="paragraph">
<p>If a full packet is available, we try to get the fix data and update the
main data structure. We also compute the DOPs so we can fill them in if
they are not included in the gps device output.</p>
</div>
<div class="paragraph">
<p>Mopst of the possible driver events are called from somewhere in here.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_wrap(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple call to
<code>gpsd_deactivate(session)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_zero_satellites(struct gps_data_t *out)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zero the status
data for all satellites.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gpsutils_c"><a class="link" href="#_gpsutils_c"><code>gpsutils.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Code shared between low-level and high-level interfaces.
Most of them do exactly what they say on the tin.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gps_clear_fix(struct gps_fix_t *fixp)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stuff a fix structure
with recognizable out-of-band values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unsigned int gps_valid_fields(struct gps_fix_t *fixp)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clears
certain status flags, depending if the associated fields are invalid.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>time_t mkgmtime(register struct tm *t)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert a struct <code>tm {}</code>
(see <code>time.h</code>) to seconds since UNIX Epoch.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timespec_t iso8601_to_timespec(char *isotime)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert an ISO8601
UTC string (like 2006-01-25T13:15:22.9Z) to a timespec_t (time_t,long).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char *timespec_to_iso8601(timespec_t ts, char isotime[], int len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert a struct timepsec into an ISO8601 UTC string (like
2006-01-25T13:15:22.9Z).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static double CalcRad(double lat)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the earth&#8217;s radius of
curvature in meters at specified latitude.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double earth_distance(double lat1, double lon1, double lat2, double lon2)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the distance in meters between two points specified in degrees.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int invert(double mat[4][4], double inverse[4][4])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Try and
invert an array. If it is possible, fill the inverted array and return a
1. Return a 0 if it is not possible.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gps_mask_t dop(struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Take a gps data
structure and try to calculate the DOP values from the other data in it.
Return 0 if it is not possible or update the appropriate DOP fields in
the structure and set a mask which tells which fields were updated.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_isgps_c"><a class="link" href="#_isgps_c"><code>isgps.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This contains low level handling for the data transmission
format of the satellite downlink and the RTCM2 radio data stream. ESR
comments &#8220;You are not expected to understand any of this.&#8221;. Let&#8217;s try
anyhow.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static unsigned char parity_array[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of parity values to
allow fast lookup instead of calculation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static unsigned int reverse_bits[]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of conversion values
to allow fast lookup instead of calculation.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unsigned int isgps_parity(isgps30bits_t th)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calculate the ISGPS
parity for the incoming 30 bit word. This involves lots of masking (with
preset values or values searched through <code>parity_array[]</code>) and
shifting</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void isgps_init(struct gps_packet_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialise the ISGPS
data for the current session.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum isgpsstat_t isgps_decode(struct gps_packet_t *session, bool (*preamble_match)(isgps30bits_t *), bool (*length_check)(struct gps_packet_t *), size_t maxlen, unsigned int c)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check the validity of the ISGPS word tag (incoming data
<code>unsigned int c</code>) and exit with an error if it is not valid.</p>
</div>
<div class="paragraph">
<p>If the session has not already locked with the datastream, loop through
the data and try and sync up. If sync is achieved, exit early with an
indication of sync, or fall through still marked unsynced.</p>
</div>
<div class="paragraph">
<p>If the session is already locked to the datastream, read the data into
the session buffer. All the while, take care that the datastream is not
corrupted. Any error will result in an early return with an appropriate
error code. At the end of this section, return the status of the
operations.</p>
</div>
<div class="paragraph">
<p>Finally, if the above two sections failed, exit with an error indicating
that lock was not achieved.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void isgps_output_magnavox(isgps30bits_t *ip, unsigned int len, FILE *fp)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ship an IS-GPS-200 message to standard output in Magnavox format.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libgps_core_c"><a class="link" href="#_libgps_core_c"><code>libgps_core.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">The client interface library for the gpsd daemon.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_data_t *gps_open(const char *host, const char *port)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Open a connection to a gps daemon.</p>
</div>
<div class="paragraph">
<p>Try to get a <code>gps_data_t</code> structure. If it fails, return a NULL.</p>
</div>
<div class="paragraph">
<p>Test for a specified host and/or port number, using defaults if nothing
is specified in the command line invocation.</p>
</div>
<div class="paragraph">
<p>Try to connect to the now defined socket; on error, release the
resources and return NULL. On success, initialise an internal struct
gps_data_t and return the pointer to it.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>struct gps_data_t *gps_open_r(const char *host, const char *port, struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Variant of <code>gps_open()</code> for when re-entrancy is required. Initializes
storage passed by the caller.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gps_close(struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Close the fd associated with the <code>gps_data_t</code> structure and stash the
result.</p>
</div>
<div class="paragraph">
<p>If there is a device id stored, NULL it and the associated path.</p>
</div>
<div class="paragraph">
<p>If the device list has any data in it, free this and mark the number of
available devices as invalid.</p>
</div>
<div class="paragraph">
<p>Free the <code>gps_data_t</code> structure itself and return the stashed
<code>close()</code> result.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gps_unpack(char *buf, struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Keep looping through the data in <code>buf</code> for JSON objects. Each time one
is found, analyze it and unpack it into the struct pointed at by
gpsdata, setting the gpsdata&#8594;set mask appropriately to indicate which
data is valid</p>
</div>
<div class="paragraph">
<p>This function is intended for GPSD internal use only and should not be
considered a stable part oof the API.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gps_poll(struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Poll the daemon and if there is no data or an error, return -1.</p>
</div>
<div class="paragraph">
<p>If there is something to read, clear the buffer, note the time as the
received data time and the online time, then unpack the data.</p>
</div>
<div class="paragraph">
<p>If profiling is active, use the received data time, the fix time and the
present time to calculate the decode time and the client receipt time.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gps_send(struct gps_data_t *gpsdata, const char *fmt, ... )</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Gather up the instructions to a gpsd instance for information to return
and write them to the device.</p>
</div>
<div class="paragraph">
<p>If the write fails, return -1. This entry point is deprecated in favor
of <code>gps_stream()</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool gps_waiting(struct gps_data_t *gpsdata)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return a boolean
indicating whether input data is waiting on the daemon socket. Does not
block.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gps_stream(struct gps_data_t *gpsdata, unsigned int, void *d)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set watch and policy flags. This evaluates the flag mask passed as the
second argument, composes a corresponding command in the GPSD write
protocol, and ships it to the daemon.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The following three functions are guarded by an <code>#ifdef</code> so they
only compile if it is required to be able to test the library and set up
a command line exerciser interface.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void data_dump(struct gps_data_t *collect, time_t now)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A
data dumper used when debugging. It outputs data according to the
command line input data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void dumpline(struct gps_data_t *ud UNUSED, char *buf, size_t ulen UNUSED, int level UNUSED)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A simple call to UNIX <code>puts()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int main(int argc, char *argv[])</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A simple command line parser and
endless loop to exercise the daemon when debugging.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based mostly on code as of Mon Apr 5 21:38:06 2010 -040.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libgps_c"><a class="link" href="#_libgps_c"><code>libgps.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">The client interface library for the gpsd daemon.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char *deg_to_str(enum deg_str_type type, double f)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Convert the absolute value of double degrees to a static string and
return a pointer to it.</p>
</div>
<div class="paragraph">
<p>Makes a simple check on invalid degree values (not more than 360) and
returns "nan" on error.</p>
</div>
<div class="paragraph">
<p>For valid values, it generates the appropriate string according to the
string type enumeration: dd, ddmm or ddmmss.</p>
</div>
<div class="paragraph">
<p>Warning: not thread safe.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+char *deg_to_str2(enum deg_str_type type, double f, char *buf,
    unsigned int buf_size, const char *suffix_pos, const char *suffix_neg)
    +</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Convert the absolute value of double degrees to a string and place in
the buffer "buf". Return a pointer to the buffer. "buf_size" is the size
of the buffer.</p>
</div>
<div class="paragraph">
<p>Makes a simple check on invalid degree values (not more than 360) and
returns "nan" on error.</p>
</div>
<div class="paragraph">
<p>For valid values, it generates the appropriate string according to the
string type enumeration: dd, ddmm or ddmmss. If the degrees are
positive, append "suffix_pos", else append "suffix_neg".</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum unit gpsd_units(void)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple check of the environment to
determine what units are required. If all else fails, use compiled in
units.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libgpsd_core_c"><a class="link" href="#_libgpsd_core_c"><code>libgpsd_core.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">General string output routine for any module to use.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_log(int errlevel, struct gpsd_errout_t, const char *fmt, ... )</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides the outputting of strings to stderr or through a specified
hook function in the errout structure for anyone who needs it. Used
extensively by many functions to log errors or progress. Responds
according to the <code>errlevel</code> argument, which is filled by the DEBUG
command line argument, so that the verbosity of output is conditional on
the user&#8217;s wishes at runtime.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Sat Mar 7 10:11:55 EST 2015</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libgpsmm_cpp"><a class="link" href="#_libgpsmm_cpp"><code>libgpsmm.cpp</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C++ class wrapper for the <code>libgps</code> C binding.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_libgpsmm_h"><a class="link" href="#_libgpsmm_h"><code>libgpsmm.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Headers for <code>libgpsmm.cpp</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_net_dgnss_dispatch_c"><a class="link" href="#_net_dgnss_dispatch_c"><code>net_dgnss_dispatch.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This file provides the interface to Differential GNSS
(Global Navigation Satellite Systems) services.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool netgnss_url(char *name)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check if a URL is valid for GNSS/DGPS
service.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int netgnss_open(struct gps_context_t *context, char *dgnss_service)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Try to open a connection to the nominated service. If the service
cannot be opened, the return is -1. The supported services are
<code>dgpsip</code> (differential corrections via IP) and <code>ntrip</code> (differential
corrections in http form).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int netgnss_poll(struct gps_context_t *context)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Try to poll the
GNSS service for a correction report. If no socket is active, simply
return 0. If a socket is active, on successful read it stores the
current timestamp and the report in the context buffer then returns 0.
If no data is ready or an error (except EAGAIN) occurs, drop the
connection and return -1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void netgnss_report(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Call the
<code>dgpsip_report()</code> or <code>ntrip_report()</code> function if either is active.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void netgnss_autoconnect(struct gps_context_t *context, double lat, double lon)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Call the <code>autoconnect()</code> function in <code>dgpsip.c</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rtcm_relay(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If there is a DGNSS
connection report in the context buffer, pass it to the caller. If the
transaction fails, generate an error log, otherwise, update the session
timestamp.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_net_dgpsip_c"><a class="link" href="#_net_dgpsip_c"><code>net_dgpsip.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This file provides the actual services for dgpsip
corrections to <code>dgnss.c</code>.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socket_t dgpsip_open(struct gps_context_t *context, const char *dgpsserver)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tries to open a connection to a dgpsip server. Returns either -1 on
failure or the socket number on success. On success, it initializes the
connection, sends a &#8220;HELO&#8221; to the server and stores the type of dgnss
service in the context data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void dgpsip_report(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If we have not
contacted the server and we have at received least 10 fixes, send a
report to the server and set the flag, so we don&#8217;t do it again.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int srvcmp(const void *s, const void *t)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compare the
distance of two servers from our location. Return -ve, 0 or ve
depending if server `+s` is nearer, the same distance away or further
away than server <code>t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void dgpsip_autoconnect(struct gps_context_t *context, double lat, double lon, const char *serverlist)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This function takes a list of servers and tries to get a connection to
the closest one relative to our location. If no servers are within 1600
km or none are in the list, the dsock value is set to -2 to lock out the
function.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_net_ntrip_c"><a class="link" href="#_net_ntrip_c"><code>net_ntrip.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Gather and dispatch DGNSS data from Ntrip broadcasters.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static char *ntrip_field_iterate(char *start, char *prev, const char *eol)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extract individual fields from the STR data block using ';' as the
separator but handling string-embedded ';' characters correctly.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void ntrip_str_parse(char *str, size_t len, struct ntrip_stream_t *hold)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Break an STR data block down using <code>ntrip_field_iterate()</code> and store
the relevant details in an accumulation buffer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int ntrip_sourcetable_parse(int fd, char *buf, ssize_t blen, const char *stream, struct ntrip_stream_t *keep)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Parse a block of ntrip data by passing the STR data to
<code>ntrip_str_parse()</code>.</p>
</div>
<div class="paragraph">
<p>Return a 0 on success or -1 on any of the many possible failures.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int ntrip_stream_probe(const char *caster, const char *port, const char *stream, struct ntrip_stream_t *keep)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send a request to the broadcaster for a block of correction data.</p>
<p class="tableblock">If successful, return the result of parsing the table. On error return
-1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int ntrip_auth_encode(const struct ntrip_stream_t *stream, const char *auth, char buf[], size_t size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check the authorisation of the stream and return 0 if there is none or
it is basic. Return -1 in all other cases.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static int ntrip_stream_open(const char *caster, const char *port, const char *auth, struct gps_context_t *context, struct ntrip_stream_t *stream)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check the authorisation of the stream and if successful, try to connect.</p>
</div>
<div class="paragraph">
<p>On connection, try to read data and test for various errors.</p>
</div>
<div class="paragraph">
<p>On success, return the socket number, on error return -1.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int ntrip_open(struct gps_context_t *context, char *caster)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Try to
establish a connection to the ntrip server. On success, return the
socket number. Signal error with a return of -1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void ntrip_report(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If we have not
contacted the server already and we have at least 10 fixes, send a
report to the server and set the flag, so we don&#8217;t do it again.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on codec as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_netlib_c"><a class="link" href="#_netlib_c"><code>netlib.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This provides socket connectivity.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int netlib_connectsock(const char *host, const char *service, const char *protocol)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This attempts to connect the to nominated service on the nominated host
using the nominated protocol. On success, the return value is the socket
number. On error, an appropriate system defined error code is returned.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>char *sock2ip(int fd)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This makes a call to <code>getpeername</code> using
the supplied fd. On success, the returned string is the ip address in
dotted notation. On error, "&lt;unknown&gt;" is returned.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ntpshmwrite_c"><a class="link" href="#_ntpshmwrite_c"><code>ntpshmwrite.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This puts time information into a shared memory segment
for the ntp daemon to use.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static struct shmTime *getShmTime(int unit)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This requests a block
of shared memory to communicate to the ntp daemon. It returns a pointer
to the memory on success or NULL on failure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void ntpshm_init(struct gps_context_t *context, bool enablepps)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attaches all ntp shared memory segments, flagging the availability of
the NMEA and 1pps capabilities as appropriate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int ntpshm_alloc(struct gps_context_t *context)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This tries to allocate a free ntp shared memory segment.</p>
</div>
<div class="paragraph">
<p>If one is available, initialise it for use and flag it as in use.</p>
</div>
<div class="paragraph">
<p>Returns the segment number on success or -1 on failure.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool ntpshm_free(struct gps_context_t *context, int segment)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This
tries to release a previously allocated ntp shared memory segment.
Indicates the outcome by returning true (success) or false.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int ntpshm_put(struct gps_device_t *session, double fixtime)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the shared memory index allocated to the session is valid and the
<code>shmTime</code> structure of the session is valid, store the time of the
fix.</p>
</div>
<div class="paragraph">
<p>Success is indicated by a return value of 1 and errors are indicated by
a return value of 0.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int ntpshm_pps(struct gps_device_t *session, struct timeval *tv)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This code is only available if the 1PPS function is compiled in.</p>
</div>
<div class="paragraph">
<p>The shared memory structures are checked for validity and if not valid,
a 0 is returned.</p>
</div>
<div class="paragraph">
<p>The time received is then checked to be within 100 milliseconds of the
PC&#8217;s internal time and if not, a -1 is returned.</p>
</div>
<div class="paragraph">
<p>The time received is then checked to be within 500 milliseconds of the
second boundary and if not, the shared memory structure is advised that
lock is lost and a -1 is returned.</p>
</div>
<div class="paragraph">
<p>If good, the time is stored in the shared memory and 1 is returned.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_packet_c"><a class="link" href="#_packet_c"><code>packet.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">The packet-sniffing engine for reading data packets from
GPS devices.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void nextstate(struct gps_packet_t *lexer, unsigned char c)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This is the main packet-sniffer loop. It scans the character against the
definitions of all the packet structures known to gpsd and, if possible,
sets a new packet state.</p>
</div>
<div class="paragraph">
<p>If the state is &#8220;xxx_RECOGNIZED&#8221;, the packet_parse routine will
dispatch the packet to the appropriate driver.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void packet_accept(struct gps_packet_t *lexer, int packet_type)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This shifts a packet that has been recognized into the output buffer,
provided it is not bigger than the buffer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void packet_discard(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This clears
a handled packet out of the input buffer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void character_discard(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This is called if the <code>nextstate()</code> function returns &#8220;GROUND_STATE&#8221;.</p>
</div>
<div class="paragraph">
<p>In this case the character does not match any pattern, so to discard it,
the input buffer is shifted back by one character to overwrite the
&#8220;bad&#8221; character.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssize_t packet_parse(struct gps_packet_t *lexer, size_t fix)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Call the <code>nextstate()</code> function to process the available data and set
the recognition state correctly.</p>
</div>
<div class="paragraph">
<p>When a packet is matched to a driver, call <code>packet_accept()</code> and
<code>packet_discard()</code> to handle the packet. If it is not matched, call
<code>packet_discard()</code> and set the state to &#8220;GROUND_STATE&#8221;</p>
</div>
<div class="paragraph">
<p>Return the number of characters handled.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssize_t packet_get(int fd, struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Reads raw data from the input port.</p>
</div>
<div class="paragraph">
<p>Returns the number of characters read (0 or more) or BAD_PACKET if there
was an error in reading.</p>
</div>
<div class="paragraph">
<p>Errors EAGAIN and EINTR are not classed as failures and cause a return
of 0.</p>
</div>
<div class="paragraph">
<p>In case of a good read of more than 0 characters, the return value is
the output from a call to <code>packet_parse()</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void packet_reset(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This simply resets
the entire packet state machine to the ground state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void packet_nit(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zeros some counters,
then resets the entire packet state machine to the ground state.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void packet_pushback(struct gps_packet_t *lexer)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This pushes back
the last packet from the output buffer to the input buffer, provided
doing so would not overflow the input buffer.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_packet_names_h"><a class="link" href="#_packet_names_h"><code>packet_names.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a file generated by the &#8220;make&#8221; process from
<code>packet_states.h</code>. It takes all the state names in that file and
surrounds them with speech marks. These values are read into a table of
packet names, <code>state_table[]</code>, in <code>packet.c</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_packet_states_h"><a class="link" href="#_packet_states_h"><code>packet_states.h</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is a list of every possible state generated by every driver. The
inclusion of each driver&#8217;s states is controlled by <code>#ifdef</code> blocks, so
we only include the states for drivers selected for compilation. These
form an enumeration list in <code>packet.c</code> which indexes the
<code>state_table[]</code> array mentioned in <code>packet_names.h</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pseudonmea_c"><a class="link" href="#_pseudonmea_c"><code>pseudonmea.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">Generate pseudo-NMEA corresponding to binary packet
reports</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static double degtodm(double a)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts a fractional degree value
(like 125.3567) into an NMEA field as dddmm.xxx (like 12521.402).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_position_fix_dump(struct gps_device_t *session, /char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If possible, create a $GPGGA message (full time, position and fix data)
from the fix data, taking care about the validity of subsidiary fields
like HDOP and altitude.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gpsd_transit_fix_dump(struct gps_device_t *session, char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create a $GPRMC message (minimum navigation data) from the fix data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gpsd_binary_fix_dump(struct gps_device_t *session, char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Make a call to <code>gpsd_position_fix_dump()</code> and
<code>gpsd_transit_fix_dump()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gpsd_binary_satellite_dump(struct gps_device_t *session, char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create one or more $GPGSV messages from the status data of all
satellites we know about.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gpsd_binary_quality_dump(struct gps_device_t *session, char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Create a $GPGSA message taking care that if any xDOP is not valid, we
substitute a &#8220;0.0&#8221; value.</p>
</div>
<div class="paragraph">
<p>If any of the error estimates is available, generate a $PGRME message
again taking care about possibly invalid values.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>static void gpsd_binary_dump(struct gps_device_t *session, char bufp[], size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dump such binary data as we have available; a fix, a quality value and
a satellite status block. Each is enabled by the appropriate status bits
in the session mask variable.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Mon Apr 5 21:38:06 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serial_c"><a class="link" href="#_serial_c"><code>serial.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This provides serial port handling services to the daemon.
It handles the tricky task of scanning for and changing port parameters,
especially baudrate.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_tty_init(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>To be called on allocating a device. Mark GPS fd closed and its baud
rate unknown.</p>
</div>
<div class="paragraph">
<p>If we are supporting <code>ntpd</code> shared memory segments, ensure they are
initially unused.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void cfmakeraw(struct termios *termios_p)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Workaround for systems
(Cygwin, Solaris), which are missing <code>cfmakeraw()</code>. It is pasted from
man page and added in <code>serial.c</code> arbitrarily.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>speed_t gpsd_get_speed(struct termios* ttyctl)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calls
<code>cfgetospeed()</code> and returns the baud rate, if known. Default otherwise
is 115200.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool gpsd_set_raw(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tries to set port
to raw mode and returns success or not.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_set_speed(struct gps_device_t *session, speed_t speed, unsigned char parity, unsigned int stopbits)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Sets the speed, parity and stopbits.</p>
</div>
<div class="paragraph">
<p>Lots of black magic fiddling goes on to ensure the port is flushed on
the baud rate change and wakeup strings are fired off just in case the
device needs prodding into life.</p>
</div>
<div class="paragraph">
<p>READ THE CODE AND COMMENTS!!!</p>
</div>
<div class="paragraph">
<p>Prior to exit, a call is made to <code>packet_reset()</code> to ensure the packet
state machine is initialised.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int gpsd_open(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Test the device and flag it as R/W if it is a character device, or R/O
if it isn&#8217;t.</p>
</div>
<div class="paragraph">
<p>Try to open it in non-blocking and no-control mode.</p>
</div>
<div class="paragraph">
<p>If that fails, try again, adding read-only mode. If that also fails,
exit with an error.</p>
</div>
<div class="paragraph">
<p>On no error, force the saved baudrate if we have a fixed port speed
(typically embedded devices). Check if we have a saved baudrate and if
so, activate it.</p>
</div>
<div class="paragraph">
<p>Preset the packet type to BAD_PACKET.</p>
</div>
<div class="paragraph">
<p>Check if the device we have opened is a tty. If it is a tty, read the
original terminal parameters.</p>
</div>
<div class="paragraph">
<p>Exit with an error code -1 on failure to do so.</p>
</div>
<div class="paragraph">
<p>Save the old parameters, set important control flags, then set the
speed.</p>
</div>
<div class="paragraph">
<p>Finally, return the allocated fd.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool gpsd_write(struct gps_device_t *session, void const *buf, size_t len)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the device is read-only, simply return 0.</p>
</div>
<div class="paragraph">
<p>If not, try to write <code>len</code> characters to the device. Waiting until all
data has been sent.</p>
</div>
<div class="paragraph">
<p>Return the number of bytes written.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool gpsd_next_hunt_setting(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Check if we have had SNIFF_RETRIES attempts at current baudrate. If not,
return &#8220;true&#8221;.</p>
</div>
<div class="paragraph">
<p>If we have exceeded the limit, reset the counter and see if there are
any more rates to try at.</p>
</div>
<div class="paragraph">
<p>If no (fixed baudrate or all attempts exhausted), return &#8220;false&#8221;,
otherwise, set the next speed and return &#8220;true&#8221;.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_assert_sync(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To be called
when we want to register that we&#8217;ve synced with a device. We&#8217;ve achieved
first sync with the device. Remember the baudrate so we can try it first
next time this device is opened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void gpsd_close(struct gps_device_t *session)</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If there is an active fd, check if it is a tty device. If it is, force
the baudrate to 0 (should terminate the connection and de-assert control
lines).</p>
</div>
<div class="paragraph">
<p>Set the HUPCL flag in the original data, write the old data to the port,
close the fd and clear that fd number from the session data.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_subframe_c"><a class="link" href="#_subframe_c"><code>subframe.c</code></a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Functions:</th>
<th class="tableblock halign-left valign-top">This code interprets satellite subframe data.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>void gpsd_interpret_subframe(struct gps_device_t *session,<br>
                                unsigned int gnssID,<br>
                                unsigned int prn,<br>
                                unsigned int words[]<br>
                                unsigned int numwords)</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extracts leap-second from subframe data.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Notes based on code as of Tue Apr 6 10:17:55 2010 -0400.  With a
few updates.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_signoff"><a class="link" href="#_signoff">Signoff</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mick Durkin &lt;<a href="mailto:mick.durkin@saunalahti.fi">mick.durkin@saunalahti.fi</a>&gt;</p>
</div>
<div class="paragraph">
<p>Helsinki</p>
</div>
<div class="paragraph">
<p>November 2007</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_revision_history"><a class="link" href="#_revision_history">Revision History</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revision</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Author</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remarks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">25 January 2020</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gem</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converted to AsciiDoc</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">25 Jan 2011</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">esr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The raw_hook member is gone.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 April 2010</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">esr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updated to match current reality, as far as it
goes. Some newer parts of the codebase, notably the JSON parsing
machinery and AIS support, aren&#8217;t documented.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14 November 2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">md</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updated to version svn revision 4420</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_copying"><a class="link" href="#_copying">COPYING</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This file is Copyright 2007 by the GPSD project<br>
SPDX-License-Identifier: BSD-2-clause</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.3<br>
Last updated 2023-01-10 17:38:26 -0500
</div>
</div>
</body>
</html>